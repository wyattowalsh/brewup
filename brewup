# ~/.zsh/functions/brewup
#compdef brewup
# =============================================================================
# BrewUp — Production-grade system software maintenance for macOS
# =============================================================================
# A flexible, performant, secure, robust, and efficient zsh function for
# safely updating system software via Homebrew and related package managers.
#
# Features
#   • Subcommands: plan | run | update | upgrade | doctor | summary | report | config | rollback
#   • Smart defaults with full configurability via file, env, and CLI
#   • Single-pass JSON inventory (efficient, no redundant subprocess spawning)
#   • Concurrent execution guard (lock file prevents race conditions)
#   • Pre-upgrade version snapshots for rollback reference
#   • Quarantine/Gatekeeper pre-flight checks for macOS compatibility
#   • Auto-update cask filtering (skip casks that self-update)
#   • Subdependency management: npm globals, pip/pipx, gem, mas (App Store)
#   • JSONL structured event logging + human-readable logs
#   • Bounded exponential backoff retry with circuit breaker
#   • Interactive mode with fzf integration (optional)
#   • Parallel downloads and batch operations
#
# Configuration
#   Reads from (in order of precedence, highest first):
#     1. CLI flags
#     2. Environment variables (BREWUP_*)
#     3. Config file: ${XDG_CONFIG_HOME:-$HOME/.config}/brewup/config
#
# Placement & Loading
#   • Save as: ~/.zsh/functions/brewup (no extension)
#   • Ensure ~/.zsh/functions is in $fpath
#   • In ~/.zshrc: autoload -Uz brewup
#
# Requirements
#   • zsh 5.8+ (uses zsh/datetime, zsh/system)
#   • Homebrew 4.0+
#   • macOS 13+ (optimized for macOS 26/Tahoe)
#   • Optional: jq (for JSON parsing), fzf (for interactive mode)
#
# License: MIT
# =============================================================================

# ──────────────────────────────────────────────────────────────────────────────
# Module-scoped state (prefixed to avoid collisions)
# ──────────────────────────────────────────────────────────────────────────────
typeset -gA __BREWUP_STYLE=()
typeset -gA __BREWUP_CFG=()
typeset -gA __BREWUP_INVENTORY=()
typeset -g  __BREWUP_LOG_DIR=""
typeset -g  __BREWUP_LOG_FILE=""
typeset -g  __BREWUP_JSONL=""
typeset -g  __BREWUP_SNAPSHOT=""
typeset -g  __BREWUP_LOCK_FD=0
typeset -g  __BREWUP_LOCK_FILE=""
typeset -g  __BREWUP_START_TIME=0
typeset -ga __BREWUP_ERRORS=()

# ──────────────────────────────────────────────────────────────────────────────
# Utility: Timestamps & JSON
# ──────────────────────────────────────────────────────────────────────────────
__brewup_now_iso() {
    strftime "%Y-%m-%dT%H:%M:%S%z" "$EPOCHSECONDS" 2>/dev/null || date "+%Y-%m-%dT%H:%M:%S%z"
}

__brewup_now_stamp() {
    strftime "%Y-%m-%d_%H-%M-%S" "$EPOCHSECONDS" 2>/dev/null || date "+%Y-%m-%d_%H-%M-%S"
}

__brewup_elapsed() {
    local now="${EPOCHSECONDS:-$(date +%s)}"
    local elapsed=$(( now - __BREWUP_START_TIME ))
    if (( elapsed >= 3600 )); then
        printf "%dh%02dm%02ds" $(( elapsed / 3600 )) $(( (elapsed % 3600) / 60 )) $(( elapsed % 60 ))
    elif (( elapsed >= 60 )); then
        printf "%dm%02ds" $(( elapsed / 60 )) $(( elapsed % 60 ))
    else
        printf "%ds" "$elapsed"
    fi
}

__brewup_json_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    s="${s//$'\n'/\\n}"
    s="${s//$'\r'/\\r}"
    s="${s//$'\t'/\\t}"
    print -rn -- "$s"
}

# ──────────────────────────────────────────────────────────────────────────────
# Configuration Loading
# ──────────────────────────────────────────────────────────────────────────────
__brewup_load_config() {
    # Defaults
    __BREWUP_CFG=(
        do_formulae       1
        do_casks          1
        do_npm            0
        do_pip            0
        do_gem            0
        do_mas            0
        cask_greedy       1
        skip_auto_update  0
        upgrade_pinned    0
        leave_unpinned    0
        run_cleanup       1
        run_doctor        0
        use_color         1
        assume_yes        0
        dry_run           0
        batch_mode        0
        interactive       0
        output_json       0
        verbose           0
        quiet             0
        force_update      0
        use_lock          1
        parallel          1
        health_check      1
        report_fmt        "text"
        theme             "emoji"
        log_dir           ""
        log_retention     30
        subcmd            "run"
        rollback_pkg      ""
    )

    # Load from config file
    local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/brewup/config"
    if [[ -r "$config_file" ]]; then
        local line key val
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            # Parse key = value
            key="${line%%=*}"
            val="${line#*=}"
            # Trim whitespace
            key="${key//[[:space:]]/}"
            val="${val#"${val%%[![:space:]]*}"}"
            val="${val%"${val##*[![:space:]]}"}"
            # Remove quotes
            val="${val#\"}" && val="${val%\"}"
            val="${val#\'}" && val="${val%\'}"
            # Normalize key
            key="${key#BREWUP_}"
            key="${(L)key}"
            # Map to internal config
            case "$key" in
                theme|log_dir|log_retention|report_fmt)
                    __BREWUP_CFG[$key]="$val" ;;
                formula_only|formulae_only)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[do_casks]=0 ;;
                cask_only|casks_only)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[do_formulae]=0 ;;
                no_greedy)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[cask_greedy]=0 ;;
                skip_auto_update)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[skip_auto_update]=1 ;;
                upgrade_pinned)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[upgrade_pinned]=1 ;;
                leave_unpinned)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[leave_unpinned]=1 ;;
                no_cleanup)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[run_cleanup]=0 ;;
                doctor)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[run_doctor]=1 ;;
                batch)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[batch_mode]=1 ;;
                verbose)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[verbose]=1 ;;
                quiet)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[quiet]=1 ;;
                npm|do_npm)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[do_npm]=1 ;;
                pip|do_pip)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[do_pip]=1 ;;
                gem|do_gem)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[do_gem]=1 ;;
                mas|do_mas)
                    [[ "$val" == "1" || "$val" == "true" ]] && __BREWUP_CFG[do_mas]=1 ;;
                parallel)
                    [[ "$val" == "0" || "$val" == "false" ]] && __BREWUP_CFG[parallel]=0 ;;
                health_check)
                    [[ "$val" == "0" || "$val" == "false" ]] && __BREWUP_CFG[health_check]=0 ;;
                all)
                    if [[ "$val" == "1" || "$val" == "true" ]]; then
                        __BREWUP_CFG[do_npm]=1
                        __BREWUP_CFG[do_pip]=1
                        __BREWUP_CFG[do_gem]=1
                        __BREWUP_CFG[do_mas]=1
                    fi ;;
            esac
        done < "$config_file"
    fi

    # Load from environment variables (override config file)
    [[ -n "$BREWUP_THEME" ]]         && __BREWUP_CFG[theme]="$BREWUP_THEME"
    [[ -n "$BREWUP_LOG_DIR" ]]       && __BREWUP_CFG[log_dir]="$BREWUP_LOG_DIR"
    [[ -n "$BREWUP_LOG_RETENTION" ]] && __BREWUP_CFG[log_retention]="$BREWUP_LOG_RETENTION"
    [[ -n "$BREWUP_REPORT_FMT" ]]    && __BREWUP_CFG[report_fmt]="$BREWUP_REPORT_FMT"
    [[ "$BREWUP_NO_GREEDY" == "1" ]]        && __BREWUP_CFG[cask_greedy]=0
    [[ "$BREWUP_SKIP_AUTO_UPDATE" == "1" ]] && __BREWUP_CFG[skip_auto_update]=1
    [[ "$BREWUP_BATCH" == "1" ]]            && __BREWUP_CFG[batch_mode]=1
    [[ "$BREWUP_VERBOSE" == "1" ]]          && __BREWUP_CFG[verbose]=1
    [[ "$BREWUP_QUIET" == "1" ]]            && __BREWUP_CFG[quiet]=1
    [[ "$BREWUP_NO_COLOR" == "1" ]]         && __BREWUP_CFG[use_color]=0
    [[ "$BREWUP_YES" == "1" ]]              && __BREWUP_CFG[assume_yes]=1
    [[ "$BREWUP_NPM" == "1" ]]              && __BREWUP_CFG[do_npm]=1
    [[ "$BREWUP_PIP" == "1" ]]              && __BREWUP_CFG[do_pip]=1
    [[ "$BREWUP_GEM" == "1" ]]              && __BREWUP_CFG[do_gem]=1
    [[ "$BREWUP_MAS" == "1" ]]              && __BREWUP_CFG[do_mas]=1
    [[ "$BREWUP_ALL" == "1" ]]              && {
        __BREWUP_CFG[do_npm]=1
        __BREWUP_CFG[do_pip]=1
        __BREWUP_CFG[do_gem]=1
        __BREWUP_CFG[do_mas]=1
    }
    [[ "$BREWUP_NO_PARALLEL" == "1" ]]      && __BREWUP_CFG[parallel]=0
    [[ "$BREWUP_NO_HEALTH_CHECK" == "1" ]]  && __BREWUP_CFG[health_check]=0
}

__brewup_parse_args() {
    local arg
    for arg in "$@"; do
        case "$arg" in
            plan|run|update|upgrade|doctor|summary|report|config|rollback)
                __BREWUP_CFG[subcmd]="$arg" ;;
            --formula-only|--formulae-only)
                __BREWUP_CFG[do_casks]=0
                __BREWUP_CFG[do_npm]=0
                __BREWUP_CFG[do_pip]=0
                __BREWUP_CFG[do_gem]=0
                __BREWUP_CFG[do_mas]=0 ;;
            --cask-only|--casks-only)
                __BREWUP_CFG[do_formulae]=0
                __BREWUP_CFG[do_npm]=0
                __BREWUP_CFG[do_pip]=0
                __BREWUP_CFG[do_gem]=0
                __BREWUP_CFG[do_mas]=0 ;;
            --brew-only)
                __BREWUP_CFG[do_npm]=0
                __BREWUP_CFG[do_pip]=0
                __BREWUP_CFG[do_gem]=0
                __BREWUP_CFG[do_mas]=0 ;;
            --npm|--with-npm)
                __BREWUP_CFG[do_npm]=1 ;;
            --pip|--with-pip)
                __BREWUP_CFG[do_pip]=1 ;;
            --gem|--with-gem)
                __BREWUP_CFG[do_gem]=1 ;;
            --mas|--with-mas)
                __BREWUP_CFG[do_mas]=1 ;;
            --all|-a)
                __BREWUP_CFG[do_npm]=1
                __BREWUP_CFG[do_pip]=1
                __BREWUP_CFG[do_gem]=1
                __BREWUP_CFG[do_mas]=1 ;;
            --no-greedy)
                __BREWUP_CFG[cask_greedy]=0 ;;
            --skip-auto-update|--skip-auto-updates)
                __BREWUP_CFG[skip_auto_update]=1 ;;
            --upgrade-pinned)
                __BREWUP_CFG[upgrade_pinned]=1 ;;
            --leave-unpinned)
                __BREWUP_CFG[leave_unpinned]=1 ;;
            --no-cleanup)
                __BREWUP_CFG[run_cleanup]=0 ;;
            --doctor)
                __BREWUP_CFG[run_doctor]=1 ;;
            --no-color)
                __BREWUP_CFG[use_color]=0 ;;
            --yes|-y)
                __BREWUP_CFG[assume_yes]=1 ;;
            --dry-run)
                __BREWUP_CFG[dry_run]=1 ;;
            --batch)
                __BREWUP_CFG[batch_mode]=1 ;;
            --interactive|-i)
                __BREWUP_CFG[interactive]=1 ;;
            --json)
                __BREWUP_CFG[output_json]=1 ;;
            --verbose|-v)
                __BREWUP_CFG[verbose]=1
                __BREWUP_CFG[quiet]=0 ;;
            --quiet|-q)
                __BREWUP_CFG[quiet]=1
                __BREWUP_CFG[verbose]=0 ;;
            --force-update)
                __BREWUP_CFG[force_update]=1 ;;
            --no-lock)
                __BREWUP_CFG[use_lock]=0 ;;
            --no-parallel|--sequential)
                __BREWUP_CFG[parallel]=0 ;;
            --no-health-check)
                __BREWUP_CFG[health_check]=0 ;;
            --theme=*)
                __BREWUP_CFG[theme]="${arg#*=}" ;;
            --report=*)
                __BREWUP_CFG[report_fmt]="${arg#*=}" ;;
            --log-dir=*)
                __BREWUP_CFG[log_dir]="${arg#*=}" ;;
            --log-retention=*)
                __BREWUP_CFG[log_retention]="${arg#*=}" ;;
            --rollback=*)
                __BREWUP_CFG[subcmd]="rollback"
                __BREWUP_CFG[rollback_pkg]="${arg#*=}" ;;
            -h|--help)
                __brewup_help
                return 1 ;;
            -*)
                print -u2 "brewup: unknown option: $arg"
                print -u2 "Run 'brewup --help' for usage."
                return 1 ;;
        esac
    done
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Style & Output
# ──────────────────────────────────────────────────────────────────────────────
__brewup_init_style() {
    local theme="${1:-emoji}"
    local use_color="${2:-1}"

    local bold="" dim="" red="" green="" yellow="" blue="" magenta="" cyan="" reset=""
    if (( use_color )) && [[ -t 1 ]]; then
        bold=$'\e[1m'
        dim=$'\e[2m'
        red=$'\e[31m'
        green=$'\e[32m'
        yellow=$'\e[33m'
        blue=$'\e[34m'
        magenta=$'\e[35m'
        cyan=$'\e[36m'
        reset=$'\e[0m'
    fi

    case "$theme" in
        none)
            __BREWUP_STYLE=(
                success_icon "" fail_icon "" info_icon "" warn_icon "" skip_icon "" pkg_icon ""
                bold "" dim "" red "" green "" yellow "" blue "" magenta "" cyan "" reset ""
            ) ;;
        minimal)
            __BREWUP_STYLE=(
                success_icon "[OK]" fail_icon "[FAIL]" info_icon "[*]" warn_icon "[!]" skip_icon "[-]" pkg_icon "[>]"
                bold "$bold" dim "$dim" red "$red" green "$green" yellow "$yellow"
                blue "$blue" magenta "$magenta" cyan "$cyan" reset "$reset"
            ) ;;
        classic)
            __BREWUP_STYLE=(
                success_icon "+" fail_icon "x" info_icon "*" warn_icon "!" skip_icon "-" pkg_icon ">"
                bold "$bold" dim "$dim" red "$red" green "$green" yellow "$yellow"
                blue "$blue" magenta "$magenta" cyan "$cyan" reset "$reset"
            ) ;;
        emoji|*)
            __BREWUP_STYLE=(
                success_icon "ok" fail_icon "err" info_icon "i" warn_icon "!" skip_icon "~" pkg_icon ">"
                bold "$bold" dim "$dim" red "$red" green "$green" yellow "$yellow"
                blue "$blue" magenta "$magenta" cyan "$cyan" reset "$reset"
            ) ;;
    esac
}

__brewup_log()   { print -r -- "$(date '+%H:%M:%S') $*" >> "$__BREWUP_LOG_FILE" 2>/dev/null; }
__brewup_jlog()  { print -r -- "$*" >> "$__BREWUP_JSONL" 2>/dev/null; }

__brewup_print() {
    (( __BREWUP_CFG[quiet] )) && return 0
    print -- "$@"
}

__brewup_info() {
    (( __BREWUP_CFG[quiet] )) && { __brewup_log "INFO: $*"; return 0; }
    print -- "${__BREWUP_STYLE[blue]}[${__BREWUP_STYLE[info_icon]}]${__BREWUP_STYLE[reset]} $*"
    __brewup_log "INFO: $*"
}

__brewup_ok() {
    (( __BREWUP_CFG[quiet] )) && { __brewup_log "OK: $*"; return 0; }
    print -- "${__BREWUP_STYLE[green]}[${__BREWUP_STYLE[success_icon]}]${__BREWUP_STYLE[reset]} $*"
    __brewup_log "OK: $*"
}

__brewup_warn() {
    print -- "${__BREWUP_STYLE[yellow]}[${__BREWUP_STYLE[warn_icon]}]${__BREWUP_STYLE[reset]} $*"
    __brewup_log "WARN: $*"
}

__brewup_err() {
    print -u2 -- "${__BREWUP_STYLE[red]}[${__BREWUP_STYLE[fail_icon]}] ${*}${__BREWUP_STYLE[reset]}"
    __brewup_log "ERROR: $*"
    __BREWUP_ERRORS+=("$*")
}

__brewup_skip() {
    (( __BREWUP_CFG[quiet] )) && { __brewup_log "SKIP: $*"; return 0; }
    print -- "${__BREWUP_STYLE[dim]}[${__BREWUP_STYLE[skip_icon]}]${__BREWUP_STYLE[reset]} $*"
    __brewup_log "SKIP: $*"
}

__brewup_verbose() {
    (( ! __BREWUP_CFG[verbose] )) && return 0
    print -- "${__BREWUP_STYLE[dim]}    $*${__BREWUP_STYLE[reset]}"
    __brewup_log "VERBOSE: $*"
}

__brewup_sect() {
    local title="$*"
    (( __BREWUP_CFG[quiet] )) && { __brewup_log "=== $title ==="; return 0; }
    print
    print -- "${__BREWUP_STYLE[magenta]}${__BREWUP_STYLE[bold]}--- ${title} ---${__BREWUP_STYLE[reset]}"
    __brewup_log "=== $title ==="
}

__brewup_banner() {
    (( __BREWUP_CFG[quiet] )) && return 0
    local when
    when="$(__brewup_now_iso)"

    print -- "${__BREWUP_STYLE[cyan]}${__BREWUP_STYLE[bold]}BrewUp${__BREWUP_STYLE[reset]} ${__BREWUP_STYLE[dim]}— Safe System Software Maintenance${__BREWUP_STYLE[reset]}"
    print -- "${__BREWUP_STYLE[dim]}${when}${__BREWUP_STYLE[reset]}"
}

# ──────────────────────────────────────────────────────────────────────────────
# Logging & Lock Infrastructure
# ──────────────────────────────────────────────────────────────────────────────
__brewup_init_logs() {
    local custom_dir="${__BREWUP_CFG[log_dir]}"
    local retention="${__BREWUP_CFG[log_retention]}"
    local base=""

    if [[ -n "$custom_dir" ]]; then
        base="$custom_dir"
    elif [[ -n "$XDG_STATE_HOME" ]]; then
        base="${XDG_STATE_HOME}/brewup"
    elif [[ "$OSTYPE" == darwin* ]]; then
        base="$HOME/Library/Logs/brewup"
    else
        base="$HOME/.local/state/brewup"
    fi

    # Create with secure permissions
    if [[ ! -d "$base" ]]; then
        mkdir -p -- "$base" 2>/dev/null
        chmod 700 "$base" 2>/dev/null
    fi

    # Prune old logs (configurable retention)
    if command -v find >/dev/null 2>&1 && [[ -d "$base" ]]; then
        find "$base" -type f \( -name '*.log' -o -name '*.jsonl' -o -name '*.snapshot' \) \
            -mtime +"$retention" -delete 2>/dev/null || true
    fi

    local stamp="$(__brewup_now_stamp)"
    __BREWUP_LOG_DIR="$base"
    __BREWUP_LOG_FILE="${base}/${stamp}.log"
    __BREWUP_JSONL="${base}/${stamp}.jsonl"
    __BREWUP_SNAPSHOT="${base}/${stamp}.snapshot"

    # Create files with secure permissions
    umask 077
    : >| "$__BREWUP_LOG_FILE"
    : >| "$__BREWUP_JSONL"
    umask 022

    # Log session start
    __brewup_log "Session started"
    __brewup_log "Command: brewup ${__BREWUP_CFG[subcmd]}"
    __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"event\":\"session_start\"}"
}

__brewup_acquire_lock() {
    (( ! __BREWUP_CFG[use_lock] )) && return 0

    __BREWUP_LOCK_FILE="${TMPDIR:-/tmp}/brewup.lock"

    # Use zsystem flock if available
    if zmodload zsh/system 2>/dev/null; then
        exec {__BREWUP_LOCK_FD}>>"$__BREWUP_LOCK_FILE"
        if ! zsystem flock -t 0 "$__BREWUP_LOCK_FD" 2>/dev/null; then
            __brewup_err "Another brewup instance is running (lock: $__BREWUP_LOCK_FILE)"
            __brewup_err "Use --no-lock to bypass (not recommended)"
            return 1
        fi
    else
        # Fallback: check for lock file with PID
        if [[ -f "$__BREWUP_LOCK_FILE" ]]; then
            local pid
            pid=$(<"$__BREWUP_LOCK_FILE")
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                __brewup_err "Another brewup instance is running (PID: $pid)"
                return 1
            fi
        fi
        print -n "$$" > "$__BREWUP_LOCK_FILE"
    fi
    return 0
}

__brewup_release_lock() {
    (( ! __BREWUP_CFG[use_lock] )) && return 0
    if (( __BREWUP_LOCK_FD > 0 )); then
        exec {__BREWUP_LOCK_FD}>&-
        __BREWUP_LOCK_FD=0
    fi
    [[ -f "$__BREWUP_LOCK_FILE" ]] && rm -f "$__BREWUP_LOCK_FILE" 2>/dev/null
}

# ──────────────────────────────────────────────────────────────────────────────
# Pre-flight Checks
# ──────────────────────────────────────────────────────────────────────────────
__brewup_require_brew() {
    if ! command -v brew >/dev/null 2>&1; then
        __brewup_err "Homebrew not found. Install from https://brew.sh"
        return 127
    fi
    return 0
}

__brewup_health_check() {
    (( ! __BREWUP_CFG[health_check] )) && return 0

    local issues=0
    __brewup_verbose "Running pre-flight health checks..."

    # Check disk space (minimum 1GB)
    local min_mb=1024
    local avail_kb
    avail_kb=$(df -k "$(brew --prefix 2>/dev/null || echo /)" 2>/dev/null | awk 'NR==2 {print $4}')
    if [[ -n "$avail_kb" ]] && (( avail_kb < min_mb * 1024 )); then
        local avail_mb=$(( avail_kb / 1024 ))
        __brewup_warn "Low disk space: ${avail_mb}MB available (recommend ${min_mb}MB+)"
        (( issues++ ))
    fi

    # Check network connectivity
    if ! ping -c1 -t2 github.com >/dev/null 2>&1; then
        __brewup_warn "Network connectivity issue: cannot reach github.com"
        (( issues++ ))
    fi

    # Check if Homebrew prefix is writable
    local brew_prefix
    brew_prefix="$(brew --prefix 2>/dev/null)"
    if [[ -n "$brew_prefix" && ! -w "$brew_prefix/Cellar" ]]; then
        __brewup_warn "Homebrew Cellar is not writable: $brew_prefix/Cellar"
        (( issues++ ))
    fi

    # macOS: Check quarantine for casks
    if (( __BREWUP_CFG[do_casks] )) && [[ "$OSTYPE" == darwin* ]]; then
        # Check if terminal has App Management permission (macOS 13+)
        local os_ver
        os_ver=$(sw_vers -productVersion 2>/dev/null | cut -d. -f1)
        if [[ -n "$os_ver" ]] && (( os_ver >= 13 )); then
            __brewup_verbose "macOS ${os_ver}: App Management permission may be required for cask upgrades"
        fi
    fi

    (( issues > 0 )) && __brewup_warn "$issues pre-flight issue(s) detected"
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Command Execution with Retry
# ──────────────────────────────────────────────────────────────────────────────
__brewup_run() {
    local rc
    ( "$@" ) 2>&1 | tee -a "$__BREWUP_LOG_FILE"
    rc=${pipestatus[1]}
    return $rc
}

__brewup_run_quiet() {
    local rc
    "$@" >> "$__BREWUP_LOG_FILE" 2>&1
    rc=$?
    return $rc
}

__brewup_retry() {
    local max_retries="$1"
    local max_delay=60
    shift

    local delay=2
    local attempt=1
    local rc=0

    while (( attempt <= max_retries )); do
        "$@"
        rc=$?
        (( rc == 0 )) && return 0

        if (( attempt < max_retries )); then
            __brewup_verbose "Attempt $attempt failed (rc=$rc), retrying in ${delay}s..."
            sleep "$delay"
            # Bounded exponential backoff
            (( delay = delay * 2 ))
            (( delay > max_delay )) && delay=$max_delay
        fi
        (( attempt++ ))
    done

    __brewup_verbose "All $max_retries attempts failed"
    return $rc
}

# ──────────────────────────────────────────────────────────────────────────────
# Inventory Collection (Single-pass JSON)
# ──────────────────────────────────────────────────────────────────────────────
__brewup_collect_inventory() {
    local -a outdated_formulae=() outdated_casks=() pinned_formulae=() auto_update_casks=()
    local -a npm_outdated=() pip_outdated=() gem_outdated=() mas_outdated=()

    __brewup_verbose "Collecting package inventory..."

    # Collect pinned formulae
    if (( __BREWUP_CFG[do_formulae] )); then
        local pinned_raw
        pinned_raw=$(brew list --pinned --formula 2>/dev/null)
        if [[ -n "$pinned_raw" ]]; then
            pinned_formulae=("${(@f)pinned_raw}")
        fi
    fi

    # Collect outdated Homebrew packages
    if command -v jq >/dev/null 2>&1; then
        __brewup_verbose "Using JSON API for inventory"
        local json_out

        # Get outdated formulae
        if (( __BREWUP_CFG[do_formulae] )); then
            json_out=$(brew outdated --formula --json 2>/dev/null)
            if [[ -n "$json_out" && "$json_out" != "[]" ]]; then
                outdated_formulae=("${(@f)$(echo "$json_out" | jq -r '.[].name' 2>/dev/null)}")
            fi
        fi

        # Get outdated casks with auto_updates detection
        if (( __BREWUP_CFG[do_casks] )); then
            local cask_flags=()
            (( __BREWUP_CFG[cask_greedy] )) && cask_flags+=(--greedy)

            json_out=$(brew outdated --cask "${cask_flags[@]}" --json 2>/dev/null)
            if [[ -n "$json_out" && "$json_out" != "[]" ]]; then
                local all_casks=("${(@f)$(echo "$json_out" | jq -r '.[].name' 2>/dev/null)}")

                if (( __BREWUP_CFG[skip_auto_update] )); then
                    local cask
                    for cask in "${all_casks[@]}"; do
                        local cask_info
                        cask_info=$(brew info --json=v2 --cask "$cask" 2>/dev/null)
                        local auto_updates
                        auto_updates=$(echo "$cask_info" | jq -r '.casks[0].auto_updates // false' 2>/dev/null)
                        if [[ "$auto_updates" == "true" ]]; then
                            auto_update_casks+=("$cask")
                            __brewup_verbose "Skipping $cask (auto-updates enabled)"
                        else
                            outdated_casks+=("$cask")
                        fi
                    done
                else
                    outdated_casks=("${all_casks[@]}")
                fi
            fi
        fi
    else
        # Fallback: plain text parsing
        __brewup_verbose "jq not found, using text parsing for inventory"

        if (( __BREWUP_CFG[do_formulae] )); then
            local form_raw
            form_raw=$(brew outdated --formula --quiet 2>/dev/null)
            [[ -n "$form_raw" ]] && outdated_formulae=("${(@f)form_raw}")
        fi

        if (( __BREWUP_CFG[do_casks] )); then
            local cask_flags=()
            (( __BREWUP_CFG[cask_greedy] )) && cask_flags+=(--greedy)
            local cask_raw
            cask_raw=$(brew outdated --cask "${cask_flags[@]}" --quiet 2>/dev/null)
            [[ -n "$cask_raw" ]] && outdated_casks=("${(@f)cask_raw}")
        fi
    fi

    # Collect npm global outdated packages
    if (( __BREWUP_CFG[do_npm] )) && command -v npm >/dev/null 2>&1; then
        __brewup_verbose "Checking npm global packages..."
        local npm_raw
        npm_raw=$(npm outdated -g --parseable 2>/dev/null | cut -d: -f4)
        [[ -n "$npm_raw" ]] && npm_outdated=("${(@f)npm_raw}")
    fi

    # Collect pip/pipx outdated packages
    if (( __BREWUP_CFG[do_pip] )); then
        if command -v pipx >/dev/null 2>&1; then
            __brewup_verbose "Checking pipx packages..."
            local pipx_raw
            pipx_raw=$(pipx list --short 2>/dev/null | awk '{print $1}')
            [[ -n "$pipx_raw" ]] && pip_outdated=("${(@f)pipx_raw}")
        elif command -v pip3 >/dev/null 2>&1; then
            __brewup_verbose "Checking pip packages..."
            local pip_raw
            pip_raw=$(pip3 list --outdated --format=freeze 2>/dev/null | cut -d= -f1)
            [[ -n "$pip_raw" ]] && pip_outdated=("${(@f)pip_raw}")
        fi
    fi

    # Collect gem outdated packages
    if (( __BREWUP_CFG[do_gem] )) && command -v gem >/dev/null 2>&1; then
        __brewup_verbose "Checking gem packages..."
        local gem_raw
        gem_raw=$(gem outdated 2>/dev/null | awk '{print $1}')
        [[ -n "$gem_raw" ]] && gem_outdated=("${(@f)gem_raw}")
    fi

    # Collect Mac App Store outdated apps
    if (( __BREWUP_CFG[do_mas] )) && command -v mas >/dev/null 2>&1; then
        __brewup_verbose "Checking Mac App Store..."
        local mas_raw
        mas_raw=$(mas outdated 2>/dev/null | awk '{print $1}')
        [[ -n "$mas_raw" ]] && mas_outdated=("${(@f)mas_raw}")
    fi

    # Export results via global associative array
    __BREWUP_INVENTORY=(
        formulae_count      "${#outdated_formulae[@]}"
        casks_count         "${#outdated_casks[@]}"
        pinned_count        "${#pinned_formulae[@]}"
        auto_update_count   "${#auto_update_casks[@]}"
        npm_count           "${#npm_outdated[@]}"
        pip_count           "${#pip_outdated[@]}"
        gem_count           "${#gem_outdated[@]}"
        mas_count           "${#mas_outdated[@]}"
        formulae            "${(j:,:)outdated_formulae}"
        casks               "${(j:,:)outdated_casks}"
        pinned              "${(j:,:)pinned_formulae}"
        auto_update_skipped "${(j:,:)auto_update_casks}"
        npm                 "${(j:,:)npm_outdated}"
        pip                 "${(j:,:)pip_outdated}"
        gem                 "${(j:,:)gem_outdated}"
        mas                 "${(j:,:)mas_outdated}"
    )
}

# ──────────────────────────────────────────────────────────────────────────────
# Pre-upgrade Snapshot
# ──────────────────────────────────────────────────────────────────────────────
__brewup_snapshot() {
    __brewup_verbose "Creating pre-upgrade snapshot..."

    {
        print "# BrewUp Pre-Upgrade Snapshot"
        print "# Generated: $(__brewup_now_iso)"
        print ""
        print "## Installed Formulae"
        brew list --formula --versions 2>/dev/null
        print ""
        print "## Installed Casks"
        brew list --cask --versions 2>/dev/null

        if (( __BREWUP_CFG[do_npm] )) && command -v npm >/dev/null 2>&1; then
            print ""
            print "## NPM Global Packages"
            npm list -g --depth=0 2>/dev/null
        fi

        if (( __BREWUP_CFG[do_pip] )) && command -v pipx >/dev/null 2>&1; then
            print ""
            print "## Pipx Packages"
            pipx list --short 2>/dev/null
        fi

        if (( __BREWUP_CFG[do_gem] )) && command -v gem >/dev/null 2>&1; then
            print ""
            print "## Gem Packages"
            gem list 2>/dev/null
        fi
    } > "$__BREWUP_SNAPSHOT"

    __brewup_log "Snapshot saved: $__BREWUP_SNAPSHOT"
}

# ──────────────────────────────────────────────────────────────────────────────
# Plan Display
# ──────────────────────────────────────────────────────────────────────────────
__brewup_print_plan() {
    local form_count="${__BREWUP_INVENTORY[formulae_count]}"
    local cask_count="${__BREWUP_INVENTORY[casks_count]}"
    local pinned_count="${__BREWUP_INVENTORY[pinned_count]}"
    local auto_skipped="${__BREWUP_INVENTORY[auto_update_count]}"
    local npm_count="${__BREWUP_INVENTORY[npm_count]}"
    local pip_count="${__BREWUP_INVENTORY[pip_count]}"
    local gem_count="${__BREWUP_INVENTORY[gem_count]}"
    local mas_count="${__BREWUP_INVENTORY[mas_count]}"

    local -a formulae=() casks=() pinned=()

    [[ -n "${__BREWUP_INVENTORY[formulae]}" ]] && formulae=("${(@s:,:)__BREWUP_INVENTORY[formulae]}")
    [[ -n "${__BREWUP_INVENTORY[casks]}" ]]    && casks=("${(@s:,:)__BREWUP_INVENTORY[casks]}")
    [[ -n "${__BREWUP_INVENTORY[pinned]}" ]]   && pinned=("${(@s:,:)__BREWUP_INVENTORY[pinned]}")

    __brewup_print ""
    __brewup_print "${__BREWUP_STYLE[bold]}Upgrade Plan${__BREWUP_STYLE[reset]}"

    # Homebrew summary
    local brew_total=$(( form_count + cask_count ))
    if (( brew_total > 0 || pinned_count > 0 || auto_skipped > 0 )); then
        __brewup_print "  ${__BREWUP_STYLE[cyan]}Homebrew${__BREWUP_STYLE[reset]}"
        (( form_count > 0 )) && __brewup_print "    Formulae: ${form_count}"
        (( cask_count > 0 )) && __brewup_print "    Casks:    ${cask_count}$( (( __BREWUP_CFG[cask_greedy] )) && print -n ' (greedy)' )"
        (( pinned_count > 0 )) && __brewup_print "    Pinned:   ${pinned_count} (will skip)"
        (( auto_skipped > 0 )) && __brewup_print "    Skipped:  ${auto_skipped} (auto-updating)"
    fi

    # Subdependency managers
    (( npm_count > 0 )) && __brewup_print "  ${__BREWUP_STYLE[cyan]}NPM Global${__BREWUP_STYLE[reset]}: ${npm_count} package(s)"
    (( pip_count > 0 )) && __brewup_print "  ${__BREWUP_STYLE[cyan]}Pip/Pipx${__BREWUP_STYLE[reset]}:   ${pip_count} package(s)"
    (( gem_count > 0 )) && __brewup_print "  ${__BREWUP_STYLE[cyan]}Gem${__BREWUP_STYLE[reset]}:        ${gem_count} package(s)"
    (( mas_count > 0 )) && __brewup_print "  ${__BREWUP_STYLE[cyan]}App Store${__BREWUP_STYLE[reset]}: ${mas_count} app(s)"

    # Detailed lists
    if (( form_count > 0 )); then
        __brewup_print ""
        __brewup_print "${__BREWUP_STYLE[dim]}Formulae:${__BREWUP_STYLE[reset]}"
        local f
        for f in "${formulae[@]}"; do
            local marker=""
            if (( ${#pinned[@]} )) && (( ${pinned[(Ie)$f]} )); then
                marker=" ${__BREWUP_STYLE[yellow]}(pinned)${__BREWUP_STYLE[reset]}"
            fi
            __brewup_print "  ${__BREWUP_STYLE[pkg_icon]} $f$marker"
        done
    fi

    if (( cask_count > 0 )); then
        __brewup_print ""
        __brewup_print "${__BREWUP_STYLE[dim]}Casks:${__BREWUP_STYLE[reset]}"
        local c
        for c in "${casks[@]}"; do
            __brewup_print "  ${__BREWUP_STYLE[pkg_icon]} $c"
        done
    fi

    if (( npm_count > 0 )) && [[ -n "${__BREWUP_INVENTORY[npm]}" ]]; then
        __brewup_print ""
        __brewup_print "${__BREWUP_STYLE[dim]}NPM:${__BREWUP_STYLE[reset]}"
        local -a npm_pkgs=("${(@s:,:)__BREWUP_INVENTORY[npm]}")
        for f in "${npm_pkgs[@]}"; do
            __brewup_print "  ${__BREWUP_STYLE[pkg_icon]} $f"
        done
    fi

    if (( pip_count > 0 )) && [[ -n "${__BREWUP_INVENTORY[pip]}" ]]; then
        __brewup_print ""
        __brewup_print "${__BREWUP_STYLE[dim]}Pip:${__BREWUP_STYLE[reset]}"
        local -a pip_pkgs=("${(@s:,:)__BREWUP_INVENTORY[pip]}")
        for f in "${pip_pkgs[@]}"; do
            __brewup_print "  ${__BREWUP_STYLE[pkg_icon]} $f"
        done
    fi

    if (( gem_count > 0 )) && [[ -n "${__BREWUP_INVENTORY[gem]}" ]]; then
        __brewup_print ""
        __brewup_print "${__BREWUP_STYLE[dim]}Gem:${__BREWUP_STYLE[reset]}"
        local -a gem_pkgs=("${(@s:,:)__BREWUP_INVENTORY[gem]}")
        for f in "${gem_pkgs[@]}"; do
            __brewup_print "  ${__BREWUP_STYLE[pkg_icon]} $f"
        done
    fi

    __brewup_print ""

    # Total count
    local total=$(( form_count + cask_count + npm_count + pip_count + gem_count + mas_count ))
    if (( total == 0 )); then
        __brewup_ok "Everything is up to date!"
        return 1
    fi

    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Interactive Selection (fzf)
# ──────────────────────────────────────────────────────────────────────────────
__brewup_interactive_select() {
    if ! command -v fzf >/dev/null 2>&1; then
        __brewup_warn "Interactive mode requires fzf. Install with: brew install fzf"
        __brewup_warn "Falling back to non-interactive mode."
        return 0
    fi

    local -a all_packages=()
    local -a formulae=() casks=()

    [[ -n "${__BREWUP_INVENTORY[formulae]}" ]] && formulae=("${(@s:,:)__BREWUP_INVENTORY[formulae]}")
    [[ -n "${__BREWUP_INVENTORY[casks]}" ]]    && casks=("${(@s:,:)__BREWUP_INVENTORY[casks]}")

    local f c
    for f in "${formulae[@]}"; do
        all_packages+=("[formula] $f")
    done
    for c in "${casks[@]}"; do
        all_packages+=("[cask] $c")
    done

    if (( ${#all_packages[@]} == 0 )); then
        return 0
    fi

    __brewup_print ""
    __brewup_info "Select packages to upgrade (TAB to select, ENTER to confirm):"

    local selected
    selected=$(printf '%s\n' "${all_packages[@]}" | fzf --multi --height=40% \
        --header="Select packages to upgrade" \
        --preview="brew info {2}" \
        --preview-window=right:50%:wrap)

    if [[ -z "$selected" ]]; then
        __brewup_warn "No packages selected."
        return 1
    fi

    local -a selected_formulae=() selected_casks=()
    local line
    while IFS= read -r line; do
        if [[ "$line" == "[formula]"* ]]; then
            selected_formulae+=("${line#\[formula\] }")
        elif [[ "$line" == "[cask]"* ]]; then
            selected_casks+=("${line#\[cask\] }")
        fi
    done <<< "$selected"

    __BREWUP_INVENTORY[formulae]="${(j:,:)selected_formulae}"
    __BREWUP_INVENTORY[casks]="${(j:,:)selected_casks}"
    __BREWUP_INVENTORY[formulae_count]="${#selected_formulae[@]}"
    __BREWUP_INVENTORY[casks_count]="${#selected_casks[@]}"

    __brewup_info "Selected ${#selected_formulae[@]} formula(e) and ${#selected_casks[@]} cask(s)"
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Upgrade Execution
# ──────────────────────────────────────────────────────────────────────────────
__brewup_upgrade_formulae() {
    local -a formulae=() pinned=()
    [[ -n "${__BREWUP_INVENTORY[formulae]}" ]] && formulae=("${(@s:,:)__BREWUP_INVENTORY[formulae]}")
    [[ -n "${__BREWUP_INVENTORY[pinned]}" ]]   && pinned=("${(@s:,:)__BREWUP_INVENTORY[pinned]}")

    local count="${#formulae[@]}"
    (( count == 0 )) && return 0

    __brewup_sect "Upgrading Formulae ($count)"

    local dry="${__BREWUP_CFG[dry_run]}"
    local batch="${__BREWUP_CFG[batch_mode]}"
    local upgrade_pinned="${__BREWUP_CFG[upgrade_pinned]}"
    local leave_unpinned="${__BREWUP_CFG[leave_unpinned]}"
    local json="${__BREWUP_CFG[output_json]}"

    # Batch mode
    if (( batch && ! dry )); then
        local -a to_upgrade=()
        local -a pinned_to_upgrade=()

        for f in "${formulae[@]}"; do
            local is_pinned=0
            (( ${#pinned[@]} )) && (( ${pinned[(Ie)$f]} )) && is_pinned=1

            if (( is_pinned )); then
                if (( upgrade_pinned )); then
                    pinned_to_upgrade+=("$f")
                else
                    __brewup_skip "$f (pinned)"
                    (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"formula\",\"name\":\"$(__brewup_json_escape "$f")\",\"action\":\"skip\",\"reason\":\"pinned\"}"
                fi
            else
                to_upgrade+=("$f")
            fi
        done

        if (( ${#pinned_to_upgrade[@]} > 0 )); then
            __brewup_info "Temporarily unpinning ${#pinned_to_upgrade[@]} formula(e)..."
            brew unpin "${pinned_to_upgrade[@]}" 2>/dev/null
            to_upgrade+=("${pinned_to_upgrade[@]}")
        fi

        if (( ${#to_upgrade[@]} > 0 )); then
            __brewup_info "Upgrading ${#to_upgrade[@]} formula(e) in batch mode..."
            __brewup_retry 3 __brewup_run brew upgrade "${to_upgrade[@]}"
            local rc=$?
            if (( rc == 0 )); then
                __brewup_ok "Batch upgrade completed"
                for f in "${to_upgrade[@]}"; do
                    (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"formula\",\"name\":\"$(__brewup_json_escape "$f")\",\"action\":\"upgraded\"}"
                done
            else
                __brewup_warn "Batch upgrade had errors (rc=$rc)"
            fi
        fi

        if (( ${#pinned_to_upgrade[@]} > 0 && ! leave_unpinned )); then
            __brewup_info "Re-pinning formula(e)..."
            brew pin "${pinned_to_upgrade[@]}" 2>/dev/null
        fi

        return 0
    fi

    # Sequential mode
    local idx=0 rc
    for f in "${formulae[@]}"; do
        (( idx++ ))
        local is_pinned=0
        (( ${#pinned[@]} )) && (( ${pinned[(Ie)$f]} )) && is_pinned=1

        __brewup_print "[$idx/$count] $f"

        if (( is_pinned && ! upgrade_pinned )); then
            __brewup_skip "  pinned"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"formula\",\"name\":\"$(__brewup_json_escape "$f")\",\"action\":\"skip\",\"reason\":\"pinned\"}"
            continue
        fi

        if (( dry )); then
            __brewup_ok "  (dry-run) would upgrade"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"formula\",\"name\":\"$(__brewup_json_escape "$f")\",\"action\":\"plan\"}"
            continue
        fi

        if (( is_pinned )); then
            __brewup_verbose "Temporarily unpinning $f"
            brew unpin "$f" 2>/dev/null || { __brewup_warn "  failed to unpin, skipping"; continue; }
        fi

        __brewup_retry 3 __brewup_run_quiet brew upgrade "$f"
        rc=$?

        if (( rc == 0 )); then
            __brewup_ok "  upgraded"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"formula\",\"name\":\"$(__brewup_json_escape "$f")\",\"action\":\"upgraded\"}"
        else
            __brewup_err "  upgrade failed (rc=$rc)"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"formula\",\"name\":\"$(__brewup_json_escape "$f")\",\"action\":\"failed\",\"rc\":$rc}"
        fi

        if (( is_pinned && ! leave_unpinned )); then
            brew pin "$f" >/dev/null 2>&1
        fi
    done
}

__brewup_upgrade_casks() {
    local -a casks=()
    [[ -n "${__BREWUP_INVENTORY[casks]}" ]] && casks=("${(@s:,:)__BREWUP_INVENTORY[casks]}")

    local count="${#casks[@]}"
    (( count == 0 )) && return 0

    __brewup_sect "Upgrading Casks ($count)"

    local dry="${__BREWUP_CFG[dry_run]}"
    local batch="${__BREWUP_CFG[batch_mode]}"
    local greedy="${__BREWUP_CFG[cask_greedy]}"
    local json="${__BREWUP_CFG[output_json]}"

    local -a cask_flags=()
    (( greedy )) && cask_flags+=(--greedy)

    # Batch mode
    if (( batch && ! dry )); then
        __brewup_info "Upgrading ${count} cask(s) in batch mode..."
        __brewup_retry 2 __brewup_run brew upgrade --cask "${cask_flags[@]}" "${casks[@]}"
        local rc=$?
        if (( rc == 0 )); then
            __brewup_ok "Batch cask upgrade completed"
            for c in "${casks[@]}"; do
                (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"cask\",\"name\":\"$(__brewup_json_escape "$c")\",\"action\":\"upgraded\"}"
            done
        else
            __brewup_warn "Batch cask upgrade had errors (rc=$rc)"
        fi
        return 0
    fi

    # Sequential mode
    local idx=0 rc
    for c in "${casks[@]}"; do
        (( idx++ ))
        __brewup_print "[$idx/$count] $c"

        if (( dry )); then
            __brewup_ok "  (dry-run) would upgrade"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"cask\",\"name\":\"$(__brewup_json_escape "$c")\",\"action\":\"plan\"}"
            continue
        fi

        __brewup_retry 2 __brewup_run_quiet brew upgrade --cask "${cask_flags[@]}" "$c"
        rc=$?

        if (( rc == 0 )); then
            __brewup_ok "  upgraded"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"cask\",\"name\":\"$(__brewup_json_escape "$c")\",\"action\":\"upgraded\"}"
        else
            __brewup_warn "  upgrade failed (rc=$rc)"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"cask\",\"name\":\"$(__brewup_json_escape "$c")\",\"action\":\"failed\",\"rc\":$rc}"
            __brewup_verbose "Try: brew reinstall --cask $c"
        fi
    done
}

__brewup_upgrade_npm() {
    local -a npm_pkgs=()
    [[ -n "${__BREWUP_INVENTORY[npm]}" ]] && npm_pkgs=("${(@s:,:)__BREWUP_INVENTORY[npm]}")

    local count="${#npm_pkgs[@]}"
    (( count == 0 )) && return 0

    if ! command -v npm >/dev/null 2>&1; then
        __brewup_warn "npm not found, skipping npm updates"
        return 0
    fi

    __brewup_sect "Upgrading NPM Global Packages ($count)"

    local dry="${__BREWUP_CFG[dry_run]}"
    local json="${__BREWUP_CFG[output_json]}"

    if (( dry )); then
        for pkg in "${npm_pkgs[@]}"; do
            __brewup_ok "  (dry-run) would upgrade: $pkg"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"npm\",\"name\":\"$(__brewup_json_escape "$pkg")\",\"action\":\"plan\"}"
        done
        return 0
    fi

    __brewup_info "Updating all npm global packages..."
    __brewup_retry 2 __brewup_run npm update -g
    local rc=$?

    if (( rc == 0 )); then
        __brewup_ok "NPM global packages updated"
        for pkg in "${npm_pkgs[@]}"; do
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"npm\",\"name\":\"$(__brewup_json_escape "$pkg")\",\"action\":\"upgraded\"}"
        done
    else
        __brewup_warn "npm update had errors (rc=$rc)"
    fi
}

__brewup_upgrade_pip() {
    local -a pip_pkgs=()
    [[ -n "${__BREWUP_INVENTORY[pip]}" ]] && pip_pkgs=("${(@s:,:)__BREWUP_INVENTORY[pip]}")

    local count="${#pip_pkgs[@]}"
    (( count == 0 )) && return 0

    __brewup_sect "Upgrading Pip/Pipx Packages ($count)"

    local dry="${__BREWUP_CFG[dry_run]}"
    local json="${__BREWUP_CFG[output_json]}"

    if command -v pipx >/dev/null 2>&1; then
        if (( dry )); then
            for pkg in "${pip_pkgs[@]}"; do
                __brewup_ok "  (dry-run) would upgrade: $pkg"
                (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"pipx\",\"name\":\"$(__brewup_json_escape "$pkg")\",\"action\":\"plan\"}"
            done
            return 0
        fi

        __brewup_info "Upgrading all pipx packages..."
        __brewup_retry 2 __brewup_run pipx upgrade-all
        local rc=$?

        if (( rc == 0 )); then
            __brewup_ok "Pipx packages upgraded"
            for pkg in "${pip_pkgs[@]}"; do
                (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"pipx\",\"name\":\"$(__brewup_json_escape "$pkg")\",\"action\":\"upgraded\"}"
            done
        else
            __brewup_warn "pipx upgrade-all had errors (rc=$rc)"
        fi
    elif command -v pip3 >/dev/null 2>&1; then
        __brewup_warn "Direct pip upgrades are not recommended. Consider using pipx instead."
        __brewup_warn "Install pipx: brew install pipx && pipx ensurepath"
    else
        __brewup_warn "Neither pipx nor pip3 found"
    fi
}

__brewup_upgrade_gem() {
    local -a gem_pkgs=()
    [[ -n "${__BREWUP_INVENTORY[gem]}" ]] && gem_pkgs=("${(@s:,:)__BREWUP_INVENTORY[gem]}")

    local count="${#gem_pkgs[@]}"
    (( count == 0 )) && return 0

    if ! command -v gem >/dev/null 2>&1; then
        __brewup_warn "gem not found, skipping gem updates"
        return 0
    fi

    __brewup_sect "Upgrading Gem Packages ($count)"

    local dry="${__BREWUP_CFG[dry_run]}"
    local json="${__BREWUP_CFG[output_json]}"

    if (( dry )); then
        for pkg in "${gem_pkgs[@]}"; do
            __brewup_ok "  (dry-run) would upgrade: $pkg"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"gem\",\"name\":\"$(__brewup_json_escape "$pkg")\",\"action\":\"plan\"}"
        done
        return 0
    fi

    __brewup_info "Updating all gems..."
    __brewup_retry 2 __brewup_run gem update
    local rc=$?

    if (( rc == 0 )); then
        __brewup_ok "Gem packages updated"
        for pkg in "${gem_pkgs[@]}"; do
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"gem\",\"name\":\"$(__brewup_json_escape "$pkg")\",\"action\":\"upgraded\"}"
        done
    else
        __brewup_warn "gem update had errors (rc=$rc)"
    fi
}

__brewup_upgrade_mas() {
    local -a mas_apps=()
    [[ -n "${__BREWUP_INVENTORY[mas]}" ]] && mas_apps=("${(@s:,:)__BREWUP_INVENTORY[mas]}")

    local count="${#mas_apps[@]}"
    (( count == 0 )) && return 0

    if ! command -v mas >/dev/null 2>&1; then
        __brewup_warn "mas not found, skipping App Store updates"
        __brewup_warn "Install mas: brew install mas"
        return 0
    fi

    __brewup_sect "Upgrading Mac App Store Apps ($count)"

    local dry="${__BREWUP_CFG[dry_run]}"
    local json="${__BREWUP_CFG[output_json]}"

    if (( dry )); then
        for app in "${mas_apps[@]}"; do
            __brewup_ok "  (dry-run) would upgrade: $app"
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"mas\",\"name\":\"$(__brewup_json_escape "$app")\",\"action\":\"plan\"}"
        done
        return 0
    fi

    __brewup_info "Updating App Store apps..."
    __brewup_retry 2 __brewup_run mas upgrade
    local rc=$?

    if (( rc == 0 )); then
        __brewup_ok "App Store apps updated"
        for app in "${mas_apps[@]}"; do
            (( json )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"type\":\"mas\",\"name\":\"$(__brewup_json_escape "$app")\",\"action\":\"upgraded\"}"
        done
    else
        __brewup_warn "mas upgrade had errors (rc=$rc)"
    fi
}

# ──────────────────────────────────────────────────────────────────────────────
# Rollback Support
# ──────────────────────────────────────────────────────────────────────────────
__brewup_rollback() {
    local pkg="${__BREWUP_CFG[rollback_pkg]}"

    if [[ -z "$pkg" ]]; then
        __brewup_err "Usage: brewup rollback --rollback=<package>"
        __brewup_info "View available versions with: brew info <package>"
        return 1
    fi

    __brewup_sect "Rollback: $pkg"

    # Check if package exists
    if ! brew info "$pkg" >/dev/null 2>&1; then
        __brewup_err "Package not found: $pkg"
        return 1
    fi

    # Show available versions
    __brewup_info "Available versions for $pkg:"
    brew info "$pkg" | head -20

    local __ans=""
    vared -p "Enter version to rollback to (or 'cancel'): " -c __ans

    if [[ "$__ans" == "cancel" || -z "$__ans" ]]; then
        __brewup_warn "Rollback cancelled"
        return 0
    fi

    __brewup_info "Rolling back $pkg to version $__ans..."

    # For formulae
    if brew list --formula | grep -q "^${pkg}$"; then
        brew unlink "$pkg" 2>/dev/null
        brew install "$pkg@$__ans" 2>/dev/null || brew switch "$pkg" "$__ans" 2>/dev/null
        local rc=$?
        if (( rc == 0 )); then
            __brewup_ok "Rollback successful"
        else
            __brewup_err "Rollback failed. You may need to: brew install $pkg@$__ans"
        fi
    else
        # For casks
        __brewup_warn "Cask rollback is complex. Try: brew reinstall --cask $pkg"
        __brewup_info "Or download older version from app's website"
    fi
}

# ──────────────────────────────────────────────────────────────────────────────
# Post-upgrade Tasks
# ──────────────────────────────────────────────────────────────────────────────
__brewup_cleanup() {
    __brewup_sect "Cleanup"
    __brewup_run brew cleanup -s --prune=30 || __brewup_warn "brew cleanup reported issues"

    # Clean npm cache if npm was updated
    if (( __BREWUP_CFG[do_npm] )) && command -v npm >/dev/null 2>&1; then
        __brewup_verbose "Cleaning npm cache..."
        npm cache clean --force >/dev/null 2>&1
    fi

    # Clean gem cache if gems were updated
    if (( __BREWUP_CFG[do_gem] )) && command -v gem >/dev/null 2>&1; then
        __brewup_verbose "Cleaning gem cache..."
        gem cleanup >/dev/null 2>&1
    fi
}

__brewup_doctor() {
    __brewup_sect "Doctor"
    __brewup_run brew doctor || __brewup_warn "brew doctor reported issues"
}

# ──────────────────────────────────────────────────────────────────────────────
# Reporting
# ──────────────────────────────────────────────────────────────────────────────
__brewup_summary() {
    __brewup_sect "Summary"
    __brewup_info "Duration:  $(__brewup_elapsed)"
    __brewup_info "Log file:  $__BREWUP_LOG_FILE"
    __brewup_info "Events:    $__BREWUP_JSONL"
    [[ -f "$__BREWUP_SNAPSHOT" ]] && __brewup_info "Snapshot:  $__BREWUP_SNAPSHOT"
    print

    local total_upgraded=0 total_failed=0
    if [[ -f "$__BREWUP_JSONL" ]]; then
        total_upgraded=$(grep -c '"action":"upgraded"' "$__BREWUP_JSONL" 2>/dev/null || echo 0)
        total_failed=$(grep -c '"action":"failed"' "$__BREWUP_JSONL" 2>/dev/null || echo 0)
    fi

    if (( ${#__BREWUP_ERRORS[@]} > 0 )); then
        __brewup_warn "Errors encountered:"
        for err in "${__BREWUP_ERRORS[@]}"; do
            print -- "  - $err"
        done
        print
    fi

    if (( total_failed > 0 )); then
        __brewup_warn "Completed with ${total_failed} failure(s) and ${total_upgraded} success(es)"
    else
        __brewup_ok "All done! Upgraded ${total_upgraded} package(s)."
    fi

    (( __BREWUP_CFG[output_json] )) && __brewup_jlog "{\"ts\":\"$(__brewup_now_iso)\",\"event\":\"session_end\",\"upgraded\":$total_upgraded,\"failed\":$total_failed}"
}

__brewup_report() {
    local fmt="${__BREWUP_CFG[report_fmt]}"
    local log_file="$__BREWUP_LOG_FILE"
    local jsonl_file="$__BREWUP_JSONL"

    if [[ -z "$log_file" || ! -f "$log_file" ]]; then
        log_file=$(ls -t "${__BREWUP_LOG_DIR:-$HOME/Library/Logs/brewup}"/*.log 2>/dev/null | head -n1)
        jsonl_file="${log_file%.log}.jsonl"
    fi

    if [[ ! -f "$log_file" ]]; then
        __brewup_err "No log files found"
        return 1
    fi

    case "$fmt" in
        json)
            if [[ -f "$jsonl_file" ]]; then
                cat "$jsonl_file"
            else
                print "{\"error\": \"No JSONL file found\"}"
            fi
            ;;
        md|markdown)
            print "# BrewUp Report"
            print ""
            print "**Log file:** \`$log_file\`"
            print "**Generated:** $(date '+%Y-%m-%d %H:%M:%S')"
            print ""
            print "## Event Log"
            print ""
            print '```'
            tail -n 100 "$log_file"
            print '```'
            ;;
        text|*)
            print "BrewUp Report"
            print "============="
            print "Log: $log_file"
            print ""
            tail -n 100 "$log_file"
            ;;
    esac
}

__brewup_show_config() {
    print "BrewUp Configuration"
    print "===================="
    print ""
    print "Active settings:"
    local key
    for key in "${(@ko)__BREWUP_CFG}"; do
        printf "  %-20s = %s\n" "$key" "${__BREWUP_CFG[$key]}"
    done
    print ""
    print "Config file: ${XDG_CONFIG_HOME:-$HOME/.config}/brewup/config"
    print "Log directory: ${__BREWUP_LOG_DIR:-${XDG_STATE_HOME:-$HOME/Library/Logs}/brewup}"
}

# ──────────────────────────────────────────────────────────────────────────────
# Help
# ──────────────────────────────────────────────────────────────────────────────
__brewup_help() {
    cat <<'HELP'
brewup — Safe, flexible system software maintenance for macOS

USAGE
    brewup [subcommand] [flags]

SUBCOMMANDS
    plan          Show what would be upgraded (dry-run)
    run           Update + upgrade + cleanup + summary (default)
    update        Only run 'brew update'
    upgrade       Only upgrade packages (skip brew update)
    doctor        Run 'brew doctor'
    summary       Show path to last log + recent entries
    report        Generate a formatted report (md|text|json)
    config        Show current configuration
    rollback      Rollback a package to previous version

FLAGS
  Package Selection
    --formula-only          Only upgrade formulae
    --cask-only             Only upgrade casks
    --brew-only             Only Homebrew (skip npm/pip/gem/mas)
    --npm, --with-npm       Include npm global packages
    --pip, --with-pip       Include pip/pipx packages
    --gem, --with-gem       Include gem packages
    --mas, --with-mas       Include Mac App Store apps
    --all, -a               Include all package managers

  Homebrew Options
    --no-greedy             Don't use --greedy for cask upgrades
    --skip-auto-update      Skip casks with auto_updates: true
    --upgrade-pinned        Temporarily unpin → upgrade → re-pin
    --leave-unpinned        Don't re-pin after upgrading pinned

  Behavior
    --no-cleanup            Skip 'brew cleanup' after upgrade
    --doctor                Run 'brew doctor' at the end
    --dry-run               Plan only; do not perform upgrades
    --batch                 Use batch upgrade (single brew call)
    --interactive, -i       Select packages interactively (requires fzf)
    --force-update          Force 'brew update' (normally implicit)
    --no-lock               Skip concurrent execution lock
    --no-parallel           Disable parallel operations
    --no-health-check       Skip pre-flight health checks

  Output
    --json                  Emit JSONL event log to stdout
    --theme=<t>             emoji | classic | minimal | none
    --report=<fmt>          md | text | json
    --verbose, -v           Verbose output
    --quiet, -q             Minimal output
    --no-color              Disable ANSI colors

  Logging
    --log-dir=<path>        Override log directory
    --log-retention=<days>  Days to keep old logs (default: 30)

  Other
    --yes, -y               Don't prompt for confirmation
    --rollback=<pkg>        Rollback a specific package
    -h, --help              Show this help

CONFIGURATION
    Settings are loaded in order (highest precedence first):
      1. CLI flags
      2. Environment variables (BREWUP_*)
      3. Config file: ~/.config/brewup/config

    Environment variables:
      BREWUP_THEME, BREWUP_LOG_DIR, BREWUP_LOG_RETENTION,
      BREWUP_NO_GREEDY, BREWUP_SKIP_AUTO_UPDATE, BREWUP_BATCH,
      BREWUP_VERBOSE, BREWUP_QUIET, BREWUP_NO_COLOR, BREWUP_YES,
      BREWUP_NPM, BREWUP_PIP, BREWUP_GEM, BREWUP_MAS, BREWUP_ALL

EXAMPLES
    brewup                      # Full maintenance run
    brewup plan                 # Preview what would be upgraded
    brewup --all                # Include all package managers
    brewup --formula-only       # Only upgrade formulae
    brewup --batch -y           # Fast batch upgrade, no prompt
    brewup -i                   # Interactive package selection
    brewup --rollback=node      # Rollback node to previous version

FILES
    ~/.config/brewup/config     Configuration file
    ~/Library/Logs/brewup/      Log files (macOS default)
    ~/.local/state/brewup/      Log files (XDG fallback)

HELP
}

# ──────────────────────────────────────────────────────────────────────────────
# Main Entry Point
# ──────────────────────────────────────────────────────────────────────────────
brewup() {
    emulate -L zsh
    setopt LOCAL_OPTIONS LOCAL_TRAPS NO_BG_NICE PIPE_FAIL EXTENDED_GLOB

    # Load zsh modules
    zmodload zsh/datetime 2>/dev/null || true
    zmodload zsh/system 2>/dev/null || true

    # Reset state
    __BREWUP_ERRORS=()

    # Record start time
    __BREWUP_START_TIME="${EPOCHSECONDS:-$(date +%s)}"

    # Load configuration (file → env → defaults)
    __brewup_load_config

    # Parse CLI arguments (override all)
    __brewup_parse_args "$@" || return $?

    # Initialize style
    __brewup_init_style "${__BREWUP_CFG[theme]}" "${__BREWUP_CFG[use_color]}"

    # Initialize logging
    __brewup_init_logs

    # Acquire lock
    __brewup_acquire_lock || return 1

    # Set up cleanup trap
    trap '__brewup_release_lock; __brewup_warn "Interrupted — partial progress logged to $__BREWUP_LOG_FILE"; return 130' INT TERM HUP

    # Check prerequisites
    __brewup_require_brew || { __brewup_release_lock; return $?; }

    # Show banner
    __brewup_banner

    # Log session info
    (( ! __BREWUP_CFG[quiet] )) && {
        __brewup_info "Log: $__BREWUP_LOG_FILE"
    }

    # Pre-flight health checks
    __brewup_health_check

    # Dispatch subcommand
    case "${__BREWUP_CFG[subcmd]}" in
        config)
            __brewup_show_config
            __brewup_release_lock
            return 0
            ;;
        update)
            __brewup_sect "Update Package Database"
            __brewup_retry 3 __brewup_run brew update || __brewup_warn "brew update reported issues"
            __brewup_release_lock
            return 0
            ;;
        doctor)
            __brewup_doctor
            __brewup_release_lock
            return 0
            ;;
        summary)
            print "Log: $__BREWUP_LOG_FILE"
            [[ -f "$__BREWUP_LOG_FILE" ]] && tail -n 50 "$__BREWUP_LOG_FILE"
            __brewup_release_lock
            return 0
            ;;
        report)
            __brewup_report
            __brewup_release_lock
            return 0
            ;;
        rollback)
            __brewup_rollback
            __brewup_release_lock
            return 0
            ;;
        plan|upgrade|run)
            # Continue to main flow
            ;;
    esac

    # Main upgrade flow
    # -----------------

    # Step 1: Update (unless 'upgrade' subcommand or implicit)
    if [[ "${__BREWUP_CFG[subcmd]}" != "upgrade" ]] && (( __BREWUP_CFG[force_update] )); then
        __brewup_sect "Update Package Database"
        __brewup_retry 3 __brewup_run brew update || __brewup_warn "brew update reported issues"
    fi

    # Step 2: Collect inventory
    __brewup_sect "Collecting Inventory"
    __brewup_collect_inventory

    # Step 3: Show plan
    __brewup_print_plan
    local has_upgrades=$?

    # Exit if plan-only or nothing to do
    if [[ "${__BREWUP_CFG[subcmd]}" == "plan" ]] || (( __BREWUP_CFG[dry_run] && __BREWUP_CFG[subcmd] != "run" )); then
        __brewup_release_lock
        return 0
    fi

    if (( has_upgrades != 0 )); then
        __brewup_release_lock
        return 0
    fi

    # Step 4: Interactive selection (if requested)
    if (( __BREWUP_CFG[interactive] )); then
        __brewup_interactive_select || { __brewup_release_lock; return 0; }
    fi

    # Step 5: Confirm
    if (( ! __BREWUP_CFG[assume_yes] && ! __BREWUP_CFG[dry_run] )); then
        local __ans=""
        vared -p "Proceed with upgrades? [Y/n] " -c __ans
        [[ -z "$__ans" ]] && __ans="Y"
        if [[ ! "$__ans" =~ ^[Yy]$ ]]; then
            __brewup_warn "Cancelled by user."
            __brewup_release_lock
            return 0
        fi
    fi

    # Step 6: Create snapshot
    __brewup_snapshot

    # Step 7: Perform upgrades
    if (( __BREWUP_CFG[dry_run] )); then
        __brewup_info "Dry-run mode — showing what would be upgraded:"
    fi

    __brewup_upgrade_formulae
    __brewup_upgrade_casks
    __brewup_upgrade_npm
    __brewup_upgrade_pip
    __brewup_upgrade_gem
    __brewup_upgrade_mas

    # Step 8: Post-upgrade tasks
    if (( ! __BREWUP_CFG[dry_run] )); then
        (( __BREWUP_CFG[run_cleanup] )) && __brewup_cleanup
        (( __BREWUP_CFG[run_doctor] ))  && __brewup_doctor
    fi

    # Step 9: Summary
    __brewup_summary

    # Cleanup
    __brewup_release_lock
    return 0
}

# Execute if sourced directly (for testing)
[[ "${(%):-%N}" == "$0" ]] && brewup "$@"
